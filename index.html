<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>TAMAYOKE // REBORN</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body {
  background:#000;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:100vh;
  font-family:'Courier New',monospace;
  overflow:hidden;
  user-select:none;
  -webkit-user-select:none;
}
#wrap { position:relative; }
canvas { display:block; touch-action:none; cursor:crosshair; }
#overlay {
  position:absolute;
  inset:0;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  background:rgba(0,4,16,0.88);
  backdrop-filter:blur(8px);
  -webkit-backdrop-filter:blur(8px);
}
.ov-logo {
  font-size:clamp(1.8em,6vw,2.6em);
  font-weight:900;
  letter-spacing:0.4em;
  color:#00f6ff;
  text-shadow:0 0 18px #00f6ff,0 0 50px #00f6ff88,0 0 100px #00f6ff44;
  margin-bottom:0.15em;
}
.ov-sub {
  font-size:0.7em;
  letter-spacing:0.5em;
  color:#446677;
  margin-bottom:1.6em;
}
.ov-legend {
  display:flex;
  flex-direction:column;
  gap:0.45em;
  margin-bottom:1.8em;
}
.ov-legend li {
  list-style:none;
  font-size:0.73em;
  color:#556688;
  letter-spacing:0.04em;
}
.ov-legend li span { color:#889aaa; }
.start-btn {
  padding:0.65em 2.8em;
  background:transparent;
  border:1.5px solid #00f6ff;
  color:#00f6ff;
  font-family:inherit;
  font-size:0.9em;
  letter-spacing:0.3em;
  cursor:pointer;
  box-shadow:0 0 18px #00f6ff55,inset 0 0 18px #00f6ff22;
  transition:box-shadow 0.2s,background 0.2s;
  -webkit-tap-highlight-color:transparent;
}
.start-btn:hover,.start-btn:active {
  background:#00f6ff18;
  box-shadow:0 0 35px #00f6ffaa,inset 0 0 25px #00f6ff44;
}
#ctrls {
  display:flex;
  justify-content:center;
  gap:18px;
  margin-top:10px;
}
.cbtn {
  width:46px;height:46px;
  border-radius:50%;
  background:rgba(0,246,255,0.07);
  border:1.5px solid rgba(0,246,255,0.35);
  color:#00f6ff;
  font-size:1.1em;
  cursor:pointer;
  display:flex;align-items:center;justify-content:center;
  -webkit-tap-highlight-color:transparent;
  transition:background 0.15s;
}
.cbtn:active { background:rgba(0,246,255,0.25); }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="cv"></canvas>
  <div id="overlay">
    <div class="ov-logo">TAMAYOKE</div>
    <div class="ov-sub">REBORN</div>
    <ul class="ov-legend">
      <li>ğŸŸ© <span>å®‰å…¨åœ°å¸¯</span> â”€ å¼¾ãŒæ¶ˆãˆã‚‹ãŒå¾—ç‚¹æ¸›å°‘</li>
      <li>ğŸ’  <span>å€é€Ÿã‚¨ãƒªã‚¢</span> â”€ ä¸­å¤®ã§å¾—ç‚¹Ã—2</li>
      <li>æ¼¢ <span>é›£èª­æ¼¢å­—å¼¾</span> â”€ æ°—ã‚’æ•£ã‚‰ã—ã¦ãã‚‹</li>
    </ul>
    <button class="start-btn" id="startBtn">â–¶ START</button>
  </div>
</div>
<div id="ctrls">
  <button class="cbtn" id="pauseBtn">â¸</button>
  <button class="cbtn" id="retryBtn">â†º</button>
</div>

<script>
'use strict';

// â”€â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const W = 420, H = 680;
cv.width = W; cv.height = H;

function resize() {
  const mw = Math.min(window.innerWidth - 4, 480);
  const mh = Math.min(window.innerHeight - 70, 740);
  const asp = W / H;
  let w, h;
  if (mw / mh < asp) { w = mw; h = w / asp; }
  else { h = mh; w = h * asp; }
  cv.style.width = w + 'px';
  cv.style.height = h + 'px';
}
resize();
window.addEventListener('resize', resize);

// â”€â”€â”€ Util â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const rand = (a, b) => Math.random() * (b - a) + a;
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const dist2 = (ax, ay, bx, by) => (ax-bx)**2 + (ay-by)**2;

// â”€â”€â”€ Overlay helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const overlay = document.getElementById('overlay');
function showOverlay(html) { overlay.innerHTML = html; overlay.style.display = 'flex'; }
function hideOverlay() { overlay.style.display = 'none'; }

// â”€â”€â”€ Stars â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STAR_COUNT = 90;
const stars = [];
for (let i = 0; i < STAR_COUNT; i++) {
  stars.push({
    x: rand(0, W), y: rand(0, H),
    s: rand(0.4, 2.2),
    spd: rand(10, 70),
    a: rand(0.2, 0.9),
    tw: rand(0, Math.PI * 2),
  });
}
function updateStars(dt) {
  for (const s of stars) {
    s.y += s.spd * dt;
    s.tw += dt * rand(1, 3);
    if (s.y > H + 4) s.y = -4;
  }
}
function drawStars() {
  for (const s of stars) {
    const a = s.a * (0.65 + 0.35 * Math.sin(s.tw));
    ctx.globalAlpha = a;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.s, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// â”€â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const particles = [];
const shockwaves = [];

function addParticle(x, y, color, count, spMin, spMax, liMin, liMax, szMin, szMax) {
  for (let i = 0; i < count; i++) {
    const a = rand(0, Math.PI * 2);
    const sp = rand(spMin, spMax);
    const li = rand(liMin, liMax);
    particles.push({ x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, color, life: li, maxLife: li, size: rand(szMin, szMax) });
  }
}

function explode(x, y) {
  ['#ff3300','#ff7700','#ffcc00','#ffffff'].forEach(c => addParticle(x, y, c, 9, 60, 280, 0.25, 0.75, 2, 6));
  shockwaves.push({ x, y, r: 0, life: 0.45, maxLife: 0.45 });
}

function engineTrail(x, y) {
  if (Math.random() > 0.55) return;
  const li = rand(0.12, 0.35);
  particles.push({ x: x + rand(-3,3), y: y + rand(6,14), vx: rand(-15,15), vy: rand(30,90), color: '#00f6ff', life: li, maxLife: li, size: rand(1,3.5) });
}

function updateFX(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.vy += 40 * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const s = shockwaves[i];
    s.r += 220 * dt;
    s.life -= dt;
    if (s.life <= 0) shockwaves.splice(i, 1);
  }
}

function drawFX() {
  for (const p of particles) {
    const t = p.life / p.maxLife;
    ctx.save();
    ctx.globalAlpha = t;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = p.size * 4;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * Math.max(0.1, t), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  for (const s of shockwaves) {
    const t = s.life / s.maxLife;
    ctx.save();
    ctx.globalAlpha = t * 0.6;
    ctx.strokeStyle = '#ff8844';
    ctx.lineWidth = 3 * t;
    ctx.shadowColor = '#ff8844';
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}

// â”€â”€â”€ Zones â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Safe zones: 4 green rectangles at the bottom
const SAFE_H = 46, SAFE_W = 72;
const SAFE_XS = [W*0.10, W*0.33, W*0.56, W*0.79];
const safeZones = SAFE_XS.map(cx => ({ x: cx - SAFE_W/2, y: H - SAFE_H, w: SAFE_W, h: SAFE_H }));

function inSafe(x, y) { return safeZones.some(z => x >= z.x && x <= z.x+z.w && y >= z.y && y <= z.y+z.h); }

// Bonus zone: center circle
const BX = W/2, BY = H * 0.34, BR = 68;
function inBonus(x, y) { return dist2(x, y, BX, BY) <= BR * BR; }

let sfPulse = 0, boPulse = 0;
function updateZones(dt) { sfPulse += dt * 2.2; boPulse += dt * 2.8; }

function drawZones() {
  // Safe zones
  for (const z of safeZones) {
    const p = 0.38 + 0.15 * Math.sin(sfPulse);
    ctx.save();
    ctx.globalAlpha = 0.10 + 0.05 * Math.sin(sfPulse);
    ctx.fillStyle = '#00ff88';
    ctx.fillRect(z.x, z.y, z.w, z.h);
    ctx.globalAlpha = p;
    ctx.strokeStyle = '#00ff88';
    ctx.lineWidth = 2;
    ctx.shadowColor = '#00ff88';
    ctx.shadowBlur = 14;
    ctx.strokeRect(z.x, z.y, z.w, z.h);
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = '#00ff88';
    ctx.font = 'bold 8px Courier New';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowBlur = 8;
    ctx.fillText('SAFE', z.x + z.w/2, z.y + z.h/2);
    ctx.restore();
  }

  // Bonus zone
  const pulse = 0.48 + 0.18 * Math.sin(boPulse);
  const r = BR + 6 * Math.sin(boPulse * 1.4);
  ctx.save();
  const grd = ctx.createRadialGradient(BX, BY, r*0.3, BX, BY, r);
  grd.addColorStop(0, 'rgba(120,40,255,0.15)');
  grd.addColorStop(1, 'rgba(80,0,180,0)');
  ctx.fillStyle = grd;
  ctx.beginPath(); ctx.arc(BX, BY, r, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = pulse;
  ctx.strokeStyle = '#aa44ff';
  ctx.lineWidth = 2.5;
  ctx.shadowColor = '#aa44ff';
  ctx.shadowBlur = 24;
  ctx.beginPath(); ctx.arc(BX, BY, r, 0, Math.PI*2); ctx.stroke();
  // Rotating dashes
  ctx.setLineDash([8, 12]);
  ctx.lineDashOffset = -boPulse * 18;
  ctx.globalAlpha = pulse * 0.4;
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(BX, BY, r * 0.7, 0, Math.PI*2); ctx.stroke();
  ctx.setLineDash([]);
  // Label
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = '#cc88ff';
  ctx.font = 'bold 12px Courier New';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowBlur = 12;
  ctx.fillText('Ã—2', BX, BY);
  ctx.restore();
}

// â”€â”€â”€ Player â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const player = { x: W/2, y: H*0.82, hitR: 5, size: 18, trail: [] };

function drawPlayer() {
  const { x, y, size: s, trail } = player;

  // Engine trail
  for (let i = 0; i < trail.length; i++) {
    const t = trail[i];
    const frac = i / trail.length;
    ctx.save();
    ctx.globalAlpha = (1 - frac) * 0.45;
    ctx.fillStyle = '#00f6ff';
    ctx.shadowColor = '#00f6ff';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(t.x, t.y, s * 0.22 * (1 - frac * 0.7), 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  ctx.save();
  ctx.shadowColor = '#00f6ff';
  ctx.shadowBlur = 22;

  // Body
  ctx.fillStyle = '#001a33';
  ctx.strokeStyle = '#00f6ff';
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.moveTo(x, y - s);
  ctx.lineTo(x + s*0.5, y + s*0.5);
  ctx.lineTo(x, y + s*0.2);
  ctx.lineTo(x - s*0.5, y + s*0.5);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Wings
  ctx.fillStyle = '#002244';
  ctx.strokeStyle = '#0099cc';
  ctx.lineWidth = 1;
  // Left wing
  ctx.beginPath();
  ctx.moveTo(x - s*0.18, y + s*0.1);
  ctx.lineTo(x - s*1.1, y + s*0.65);
  ctx.lineTo(x - s*0.5, y + s*0.5);
  ctx.closePath();
  ctx.fill(); ctx.stroke();
  // Right wing
  ctx.beginPath();
  ctx.moveTo(x + s*0.18, y + s*0.1);
  ctx.lineTo(x + s*1.1, y + s*0.65);
  ctx.lineTo(x + s*0.5, y + s*0.5);
  ctx.closePath();
  ctx.fill(); ctx.stroke();

  // Engine glow
  const eg = ctx.createRadialGradient(x, y+s*0.4, 0, x, y+s*0.4, s*0.5);
  eg.addColorStop(0, 'rgba(0,246,255,0.9)');
  eg.addColorStop(0.5, 'rgba(0,120,255,0.5)');
  eg.addColorStop(1, 'rgba(0,0,80,0)');
  ctx.fillStyle = eg;
  ctx.beginPath();
  ctx.ellipse(x, y+s*0.38, s*0.16, s*0.42, 0, 0, Math.PI*2);
  ctx.fill();

  // Cockpit
  ctx.shadowBlur = 6;
  ctx.fillStyle = '#00f6ff33';
  ctx.strokeStyle = '#00f6ff66';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(x, y - s*0.15, s*0.18, s*0.32, 0, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();

  // Hitbox dot
  ctx.globalAlpha = 0.35;
  ctx.shadowBlur = 0;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.arc(x, y, player.hitR, 0, Math.PI*2);
  ctx.stroke();

  ctx.restore();
}

// â”€â”€â”€ Kanji Pool â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const KANJI = [
  {k:'é›°å›²æ°—',f:'ãµã‚“ã„ã'},{k:'æ—©æ€¥',f:'ã•ã£ãã‚…ã†'},{k:'é‡è¤‡',f:'ã¡ã‚‡ã†ãµã'},
  {k:'ç›¸æ®º',f:'ãã†ã•ã„'},{k:'ä»£æ›¿',f:'ã ã„ãŸã„'},{k:'ç¨€æœ‰',f:'ã‘ã†'},
  {k:'æ—¢è¦–æ„Ÿ',f:'ãã—ã‹ã‚“'},{k:'äº”æœˆé›¨',f:'ã•ã¿ã ã‚Œ'},{k:'ä¸€æ®µè½',f:'ã²ã¨ã ã‚“ã‚‰ã'},
  {k:'å‡ºæ±',f:'ã ã—'},{k:'å‰²æ„›',f:'ã‹ã¤ã‚ã„'},{k:'ç ´ç¶»',f:'ã¯ãŸã‚“'},
  {k:'æ‚ªå¯’',f:'ãŠã‹ã‚“'},{k:'æµçŸ³',f:'ã•ã™ãŒ'},{k:'è´”å±“',f:'ã²ã„ã'},
  {k:'èºŠèº‡',f:'ã¡ã‚…ã†ã¡ã‚‡'},{k:'ç‹¡çŒ¾',f:'ã“ã†ã‹ã¤'},{k:'æ–¡æ—‹',f:'ã‚ã£ã›ã‚“'},
  {k:'å³å¾€å·¦å¾€',f:'ã†ãŠã†ã•ãŠã†'},{k:'é ¬æ–',f:'ã»ãŠã¥ãˆ'},
  {k:'è–”è–‡',f:'ã°ã‚‰'},{k:'æª¸æª¬',f:'ã‚Œã‚‚ã‚“'},{k:'è‘¡è„',f:'ã¶ã©ã†'},
  {k:'å‘æ—¥è‘µ',f:'ã²ã¾ã‚ã‚Š'},{k:'æµ·æœˆ',f:'ãã‚‰ã’'},
  {k:'æ‰€è¬‚',f:'ã„ã‚ã‚†ã‚‹'},{k:'é¡°è¹™',f:'ã²ã‚“ã—ã‚…ã'},{k:'æ®ºé™£',f:'ãŸã¦'},
  {k:'æ¼¸ã',f:'ã‚ˆã†ã‚„ã'},{k:'å‡¡ä¾‹',f:'ã¯ã‚“ã‚Œã„'},{k:'å±±èŒ¶èŠ±',f:'ã•ã–ã‚“ã‹'},
  {k:'ç§‹æ¡œ',f:'ã“ã™ã‚‚ã™'},{k:'çŸ³æ¥ èŠ±',f:'ã—ã‚ƒããªã’'},{k:'åˆç‚¹',f:'ãŒã£ã¦ã‚“'},
  {k:'å‡¡ã',f:'ãŠã‚ˆã'},{k:'æ•™å”†',f:'ãã‚‡ã†ã•'},{k:'å—œå¥½',f:'ã—ã“ã†'},
];
let lastKIdx = -1;
function pickKanji() {
  let i = Math.floor(Math.random() * KANJI.length);
  if (KANJI.length > 1 && i === lastKIdx) i = (i + 1) % KANJI.length;
  lastKIdx = i;
  return KANJI[i];
}

// â”€â”€â”€ Bullets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Bullet {
  constructor(x, y, vx, vy, r=7, hitR=4, col='#00f6ff') {
    this.x=x; this.y=y; this.vx=vx; this.vy=vy;
    this.r=r; this.hitR=hitR; this.col=col;
    this.alive=true; this.trail=[];
  }
  update(dt) {
    this.trail.unshift({x:this.x, y:this.y});
    if (this.trail.length > 5) this.trail.pop();
    this.x += this.vx*dt; this.y += this.vy*dt;
    if (inSafe(this.x, this.y)) {
      addParticle(this.x, this.y, '#00ff88', 4, 25, 70, 0.15, 0.4, 1, 2.5);
      this.alive = false; return;
    }
    const M=70;
    if (this.x<-M||this.x>W+M||this.y<-M||this.y>H+M) this.alive=false;
  }
  draw() {
    for (let i=0; i<this.trail.length; i++) {
      const t=this.trail[i], frac=1-i/this.trail.length;
      ctx.save(); ctx.globalAlpha=frac*0.35;
      ctx.fillStyle=this.col;
      ctx.beginPath(); ctx.arc(t.x, t.y, this.r*frac*0.65, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
    ctx.save();
    ctx.shadowColor=this.col; ctx.shadowBlur=16;
    ctx.fillStyle=this.col;
    ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=0.55;
    ctx.fillStyle='#fff';
    ctx.beginPath(); ctx.arc(this.x-this.r*0.3, this.y-this.r*0.3, this.r*0.32, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

class KanjiBullet {
  constructor(x, y, vx, vy, kanji, furigana) {
    this.x=x; this.y=y; this.vx=vx; this.vy=vy;
    this.kanji=kanji; this.furigana=furigana;
    this.hitR=5; this.r=50;
    this.alive=true;
    this.rot=rand(-0.08,0.08); this.rotV=rand(-0.6,0.6);
    this.wob=rand(0,Math.PI*2);
    this.glitchT=rand(1.5,4); this.glitch=false; this.glitchDur=0;
    // Random warning color
    this.warnHue = Math.floor(rand(0,40));
  }
  update(dt) {
    this.x+=this.vx*dt; this.y+=this.vy*dt;
    this.rot+=this.rotV*dt; this.wob+=dt*2.8;
    this.glitchT-=dt;
    if (this.glitchT<=0) {
      this.glitch=true; this.glitchDur=rand(0.08,0.28);
      this.glitchT=rand(1.2,3.5);
    }
    if (this.glitch) { this.glitchDur-=dt; if(this.glitchDur<=0) this.glitch=false; }
    if (inSafe(this.x, this.y)) {
      addParticle(this.x,this.y,'#ff4400',10,50,150,0.3,0.8,2,5);
      this.alive=false; return;
    }
    const M=130;
    if (this.x<-M||this.x>W+M||this.y<-M||this.y>H+M) this.alive=false;
  }
  draw() {
    const r = this.r;
    const wr = r + 4*Math.sin(this.wob);
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rot);

    // Outer danger ring
    ctx.globalAlpha = 0.22+0.1*Math.sin(this.wob*2.5);
    ctx.strokeStyle = `hsl(${this.warnHue},100%,60%)`;
    ctx.lineWidth = 3.5;
    ctx.shadowColor = `hsl(${this.warnHue},100%,60%)`;
    ctx.shadowBlur = 18;
    ctx.beginPath(); ctx.arc(0, 0, wr+10, 0, Math.PI*2); ctx.stroke();

    // Background
    ctx.globalAlpha = 0.9;
    const bg = ctx.createRadialGradient(0,0,r*0.15,0,0,r);
    bg.addColorStop(0,'#160000'); bg.addColorStop(0.65,'#0d0000'); bg.addColorStop(1,'#2a0000');
    ctx.fillStyle = bg;
    ctx.shadowColor = `hsl(${this.warnHue},100%,50%)`;
    ctx.shadowBlur = 24;
    ctx.beginPath(); ctx.arc(0, 0, wr, 0, Math.PI*2); ctx.fill();

    // Border
    ctx.globalAlpha = 0.75;
    ctx.strokeStyle = `hsl(${this.warnHue},100%,55%)`;
    ctx.lineWidth = 2.2;
    ctx.shadowBlur = 16;
    ctx.beginPath(); ctx.arc(0, 0, wr, 0, Math.PI*2); ctx.stroke();

    // Scan lines
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = '#ff4444';
    ctx.lineWidth = 1;
    ctx.shadowBlur = 0;
    for (let ly=-r; ly<r; ly+=5) {
      ctx.beginPath(); ctx.moveTo(-r,ly); ctx.lineTo(r,ly); ctx.stroke();
    }

    // Glitch effect
    if (this.glitch) {
      [[-4,-1,'rgba(255,0,0,0.6)'],[4,1,'rgba(0,255,200,0.6)']].forEach(([ox,oy,c])=>{
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = c;
        ctx.font = `bold ${Math.floor(r*0.62)}px 'Noto Sans JP',serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.shadowBlur = 0;
        ctx.fillText(this.kanji, ox, oy - r*0.1);
      });
    }

    // Kanji text
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#ffe8d0';
    ctx.font = `bold ${Math.floor(r*0.62)}px 'Noto Sans JP',serif`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(this.kanji, 0, -r*0.1);

    // Furigana
    ctx.fillStyle = '#ff5555';
    ctx.font = `bold ${Math.floor(r*0.3)}px 'Noto Sans JP',serif`;
    ctx.textBaseline = 'top';
    ctx.fillText(this.furigana, 0, r*0.2);

    ctx.restore();
  }
}

// â”€â”€â”€ Bullet Container & Timers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const bullets = [];
const timers = {};
function every(key, interval, fn, dt) {
  if (timers[key] === undefined) timers[key] = 0;
  timers[key] += dt;
  while (timers[key] >= interval) { timers[key] -= interval; fn(); }
}

function hsl(h) { return `hsl(${h},100%,62%)`; }

// Spawn helpers
function spawnRow(n, vy, hue) {
  const gap = W / (n+1);
  for (let i=1; i<=n; i++) bullets.push(new Bullet(gap*i,-12,rand(-18,18),vy,7,4,hsl(hue)));
}
function spawnRain(vy, hue) {
  bullets.push(new Bullet(rand(20,W-20),-12,rand(-22,22),vy,7,4,hsl(hue)));
}
function spawnRing(cx, cy, n, spd, hue) {
  for (let i=0; i<n; i++) {
    const a=(i/n)*Math.PI*2;
    bullets.push(new Bullet(cx,cy,Math.cos(a)*spd,Math.sin(a)*spd,6,3,hsl(hue)));
  }
}
function spawnAimed(fromX, fromY, toX, toY, spd, r, hue, spread=0) {
  const base = Math.atan2(toY-fromY, toX-fromX);
  const offsets = spread===0 ? [0] : [-spread,0,spread];
  for (const off of offsets) {
    const a = base+off;
    bullets.push(new Bullet(fromX,fromY,Math.cos(a)*spd,Math.sin(a)*spd,r,4,hsl(hue)));
  }
}
function spawnSide(side, n, spd, hue) {
  const x = side==='left' ? -8 : W+8, dir = side==='left' ? 1 : -1;
  const sy = rand(H*0.2, H*0.75);
  for (let i=0; i<n; i++) {
    bullets.push(new Bullet(x, sy+i*12-n*6, dir*(spd+rand(-25,25)), rand(-50,50), 7,4,hsl(hue)));
  }
}
let spiralA = 0;
function spawnSpiral(cx, cy, n, spd, hue) {
  for (let i=0; i<n; i++) {
    const a=(i/n)*Math.PI*2+spiralA;
    bullets.push(new Bullet(cx,cy,Math.cos(a)*spd,Math.sin(a)*spd,6,3,hsl(hue)));
  }
  spiralA += 0.35;
}
function spawnKanji() {
  const pk = pickKanji();
  const x = rand(80, W-80), y = -65;
  const spd = 105 + difficulty*14;
  const a = Math.atan2(player.y-y, player.x-x);
  bullets.push(new KanjiBullet(x,y,Math.cos(a)*spd,Math.sin(a)*spd,pk.k,pk.f));
}

// â”€â”€â”€ Game State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let running=false, paused=false, dead=false;
let time=0, score=0, difficulty=1, zone='normal';
let screenShake=0;
let hiscore=0;
try { hiscore = Number(localStorage.getItem('tamayoke_reborn_hi')||0); } catch(e){}

const GRACE = 2.8;
const keys = new Set();
const ptr = { active:false, x:W/2, y:H*0.82 };

// Banners
const banners = [];
let nextMile=2000, mileCount=0;
const COMPLIMENTS=['ã„ã„ã­ï¼','ãã®èª¿å­ï¼','ã‚­ãƒã£ã¦ã‚‹ï¼','ã™ã”ã„ï¼','çµ¶å¥½èª¿ï¼','è¦šé†’ï¼','ç„¡åŒï¼','åœ§å€’çš„ï¼','ä¼èª¬ï¼','ç¥ã£ã¦ã‚‹ï¼'];
function banner(text) {
  banners.push({ text, life:2.4, maxLife:2.4, y:H*0.22 });
}
function updateBanners(dt) {
  for (let i=banners.length-1; i>=0; i--) {
    const b=banners[i]; b.life-=dt; b.y-=18*dt;
    if (b.life<=0) banners.splice(i,1);
  }
}
function drawBanners() {
  for (const b of banners) {
    const a = b.life<0.6 ? b.life/0.6 : Math.min(1,(b.maxLife-b.life)/0.25);
    ctx.save();
    ctx.globalAlpha = Math.max(0,a);
    ctx.font = `900 34px ui-sans-serif,'Noto Sans JP',sans-serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='#ff8800'; ctx.shadowBlur=22;
    ctx.strokeStyle='#000'; ctx.lineWidth=4;
    ctx.strokeText(b.text, W/2, b.y);
    ctx.fillStyle='#ffe566';
    ctx.fillText(b.text, W/2, b.y);
    ctx.restore();
  }
}

// â”€â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawHUD() {
  let scCol='#66aaff', zLabel='';
  if (zone==='safe') { scCol='#ff4444'; zLabel='âš  SAFE ZONE'; }
  else if (zone==='bonus') { scCol='#bb77ff'; zLabel='âœ¦ Ã—2 BONUS'; }

  ctx.save();
  ctx.shadowColor=scCol; ctx.shadowBlur=16;
  ctx.fillStyle=scCol;
  ctx.font='bold 38px Courier New';
  ctx.textAlign='right'; ctx.textBaseline='top';
  ctx.fillText(Math.floor(score), W-12, 10);

  ctx.shadowBlur=5;
  ctx.font='12px Courier New';
  ctx.fillStyle='rgba(255,255,255,0.35)';
  ctx.textAlign='left';
  ctx.fillText(`BEST ${hiscore}`, 12, 14);
  ctx.fillText(`TIME ${time.toFixed(1)}s`, 12, 30);

  if (zLabel) {
    ctx.font='bold 11px Courier New';
    ctx.fillStyle=scCol;
    ctx.textAlign='center';
    ctx.shadowBlur=10;
    ctx.fillText(zLabel, W/2, 12);
  }

  // Grace countdown
  if (time < GRACE) {
    const cd = Math.ceil(GRACE - time);
    ctx.globalAlpha = 0.7;
    ctx.font=`bold 90px Courier New`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle='#fff';
    ctx.shadowColor='#00f6ff'; ctx.shadowBlur=40;
    ctx.fillText(cd, W/2, H/2 - 55);
  }

  // Difficulty bar
  const barW = 80, barH = 4;
  const bx = W - barW - 12, by = H - 14;
  const dFrac = Math.min(1, (difficulty - 1) / 8);
  ctx.globalAlpha = 0.5;
  ctx.fillStyle='#222';
  ctx.fillRect(bx, by, barW, barH);
  const dCol = `hsl(${120 - dFrac*120},100%,55%)`;
  ctx.fillStyle=dCol;
  ctx.shadowColor=dCol; ctx.shadowBlur=6;
  ctx.fillRect(bx, by, barW*dFrac, barH);
  ctx.globalAlpha=0.3;
  ctx.fillStyle='#fff';
  ctx.font='9px Courier New'; ctx.textAlign='right';
  ctx.fillText('DIFFICULTY', bx-4, by+barH-1);

  ctx.restore();
}

// â”€â”€â”€ Background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBg() {
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#000812'); g.addColorStop(0.5,'#000a20'); g.addColorStop(1,'#010022');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // Perspective grid
  ctx.save();
  ctx.globalAlpha=0.055;
  ctx.strokeStyle='#0088cc'; ctx.lineWidth=0.6;
  const gy0 = H*0.52;
  for (let y=gy0; y<H; y+=22) {
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  for (let i=-6; i<=16; i++) {
    ctx.beginPath();
    ctx.moveTo(W/2+i*9, gy0);
    ctx.lineTo(W/2+i*32, H);
    ctx.stroke();
  }
  ctx.restore();

  // Nebula-ish glow
  const nebG = ctx.createRadialGradient(W*0.75,H*0.2,0,W*0.75,H*0.2,160);
  nebG.addColorStop(0,'rgba(60,0,120,0.06)');
  nebG.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=nebG; ctx.fillRect(0,0,W,H);
  const nebG2 = ctx.createRadialGradient(W*0.2,H*0.7,0,W*0.2,H*0.7,120);
  nebG2.addColorStop(0,'rgba(0,80,100,0.07)');
  nebG2.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=nebG2; ctx.fillRect(0,0,W,H);
}

// â”€â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update(dt) {
  time += dt;
  const tEff = Math.max(0, time - GRACE);
  difficulty = 1 + tEff * 0.065;

  // Score
  let mult = 1;
  if (zone==='bonus') mult = 2;
  else if (zone==='safe') mult = -8;
  score += dt * 100 * mult;
  if (score < 0) { gameOver(); return; }

  // Milestone
  if (score >= nextMile) {
    mileCount++;
    banner(COMPLIMENTS[Math.min(mileCount-1, COMPLIMENTS.length-1)]);
    nextMile += 2000 + mileCount*150;
    sfx('milestone');
  }

  // Player movement
  const spd = 310;
  if (ptr.active) {
    const dx=ptr.x-player.x, dy=ptr.y-player.y;
    const d=Math.hypot(dx,dy), mv=spd*dt;
    if (d<mv) { player.x=ptr.x; player.y=ptr.y; }
    else { player.x+=dx/d*mv; player.y+=dy/d*mv; }
  } else {
    let dx=0, dy=0;
    if (keys.has('ArrowLeft')||keys.has('KeyA')) dx-=1;
    if (keys.has('ArrowRight')||keys.has('KeyD')) dx+=1;
    if (keys.has('ArrowUp')||keys.has('KeyW')) dy-=1;
    if (keys.has('ArrowDown')||keys.has('KeyS')) dy+=1;
    const len=Math.hypot(dx,dy)||1;
    player.x=clamp(player.x+dx/len*spd*dt,12,W-12);
    player.y=clamp(player.y+dy/len*spd*dt,12,H-12);
  }
  player.x=clamp(player.x,12,W-12);
  player.y=clamp(player.y,12,H-12);

  // Trail
  player.trail.unshift({x:player.x, y:player.y});
  if (player.trail.length>14) player.trail.pop();

  // Zone
  let nz='normal';
  if (inSafe(player.x,player.y)) nz='safe';
  else if (inBonus(player.x,player.y)) nz='bonus';
  if (nz!==zone) { zone=nz; sfx('zone_'+nz); }

  // Spawning
  if (time>=GRACE) {
    const d=difficulty;
    every('row',   Math.max(1.6, 5.5-d*0.35),  ()=>spawnRow(Math.floor(4+d*0.5),100+d*9, 190),         dt);
    every('rain',  Math.max(0.45,1.8-d*0.05),   ()=>spawnRain(125+d*8, rand(155,225)),                  dt);
    every('side',  Math.max(1.0, 3.8-d*0.12),   ()=>spawnSide(Math.random()<.5?'left':'right',Math.floor(6+d),175+d*9,rand(40,80)), dt);
    every('ring',  Math.max(4.5, 9-d*0.25),     ()=>spawnRing(rand(W*.2,W*.8),rand(H*.15,H*.5),Math.floor(22+d*2),115+d*9,300), dt);
    every('aimed', Math.max(0.9, 2.8-d*0.08),   ()=>{
      const ex=Math.random()<.5?rand(0,W):(Math.random()<.5?-8:W+8);
      const ey=ex<-5||ex>W+5?rand(H*.2,H*.65):-8;
      spawnAimed(ex,ey,player.x,player.y,125+d*11,8,0,d>3?0.18:0);
    }, dt);
    every('spiral',Math.max(5.5,12-d*0.45),     ()=>spawnSpiral(rand(W*.2,W*.8),rand(H*.1,H*.45),Math.floor(26+d*3),115+d*10,270), dt);
    every('kanji', Math.max(2.8, 6.5-d*0.18),   ()=>spawnKanji(), dt);
  }

  // Bullets
  const pr=player.hitR, px=player.x, py=player.y;
  for (let i=bullets.length-1; i>=0; i--) {
    const b=bullets[i];
    b.update(dt);
    if (!b.alive) { bullets.splice(i,1); continue; }
    if (dist2(px,py,b.x,b.y) <= (pr+b.hitR)**2) { gameOver(); return; }
  }

  screenShake *= 0.82;
  updateStars(dt);
  updateFX(dt);
  updateZones(dt);
  updateBanners(dt);
  engineTrail(player.x, player.y);
}

// â”€â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw() {
  ctx.save();
  if (screenShake > 0.6) ctx.translate((Math.random()-.5)*screenShake,(Math.random()-.5)*screenShake);

  drawBg();
  drawStars();
  drawZones();

  // Kanji first (behind regular bullets)
  for (const b of bullets) { if (b instanceof KanjiBullet) b.draw(); }
  drawFX();
  for (const b of bullets) { if (!(b instanceof KanjiBullet)) b.draw(); }

  drawPlayer();
  ctx.restore();

  drawHUD();
  drawBanners();
}

// â”€â”€â”€ Audio : ZUNTATA-STYLE ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Inspired by Darius Gaiden / RayForce (ZUNTATA)
// FM synthesis + drum machine + chord sequencer

let AC=null, masterGain=null, reverbNode=null, reverbSend=null;
let audioOK=false, bonusT=null;

// BGM sequencer state
let bgmInterval=null, bgmRunning=false;
let bgmNextNote=0, bgmStep=0, bgmBar=0;

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initAudio() {
  if (audioOK) return;
  const Ctx=window.AudioContext||window.webkitAudioContext;
  if (!Ctx) return;
  AC=new Ctx();

  // Master compressor (glues the mix)
  const comp=AC.createDynamicsCompressor();
  comp.threshold.value=-16; comp.knee.value=8;
  comp.ratio.value=4; comp.attack.value=0.004; comp.release.value=0.12;
  comp.connect(AC.destination);

  masterGain=AC.createGain(); masterGain.gain.value=0.78;
  masterGain.connect(comp);

  // Reverb (synthetic impulse response)
  const rvLen=Math.floor(AC.sampleRate*1.6);
  const rvBuf=AC.createBuffer(2,rvLen,AC.sampleRate);
  for(let ch=0;ch<2;ch++){
    const d=rvBuf.getChannelData(ch);
    for(let i=0;i<rvLen;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/rvLen,2.8)*(ch===1?Math.cos(i*0.0003):1);
  }
  reverbNode=AC.createConvolver(); reverbNode.buffer=rvBuf;
  reverbSend=AC.createGain(); reverbSend.gain.value=0.22;
  reverbNode.connect(reverbSend); reverbSend.connect(masterGain);

  audioOK=true;
}

// â”€â”€ Low-level helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const mf=n=>440*Math.pow(2,(n-69)/12); // MIDI â†’ Hz

function connectRv(node,amt=0.28){
  if(!reverbNode) return;
  const s=AC.createGain(); s.gain.value=amt;
  node.connect(s); s.connect(reverbNode);
}

// FM voice: modulator â†’ carrier frequency (classic FM synthesis)
function fmNote(when,midi,dur,modR=2,modI=4,vol=0.12,dt=0){
  if(!audioOK)return;
  const f=mf(midi);
  // Modulator: sine at f*modR, output scaled to modI*f and added to carrier freq
  const mod=AC.createOscillator(); mod.type='sine'; mod.frequency.value=f*modR;
  const modG=AC.createGain();
  modG.gain.setValueAtTime(modI*f, when);
  modG.gain.exponentialRampToValueAtTime(modI*f*0.04, when+dur);
  mod.connect(modG);
  // Carrier: sine at base freq, frequency-modulated by modG
  const car=AC.createOscillator(); car.type='sine';
  car.frequency.value=f; car.detune.value=dt;
  modG.connect(car.frequency);
  // Amplitude envelope
  const env=AC.createGain();
  env.gain.setValueAtTime(0.0001, when);
  env.gain.linearRampToValueAtTime(vol, when+0.007);
  env.gain.setValueAtTime(vol, when+dur*0.6);
  env.gain.exponentialRampToValueAtTime(0.0001, when+dur);
  car.connect(env); env.connect(masterGain); connectRv(env, 0.3);
  mod.start(when); mod.stop(when+dur+0.04);
  car.start(when); car.stop(when+dur+0.04);
}

// Lead: dual detuned square + sawtooth + LP filter
function leadNote(when,midi,dur,vol=0.11){
  if(!audioOK)return;
  const f=mf(midi);
  const o1=AC.createOscillator(), o2=AC.createOscillator();
  o1.type='square'; o2.type='sawtooth';
  o1.frequency.value=f; o2.frequency.value=f;
  o1.detune.value=7; o2.detune.value=-7;
  const flt=AC.createBiquadFilter(); flt.type='lowpass';
  flt.frequency.setValueAtTime(f*10,when); flt.frequency.exponentialRampToValueAtTime(f*2.5,when+dur); flt.Q.value=2.5;
  const env=AC.createGain();
  env.gain.setValueAtTime(0.0001,when); env.gain.linearRampToValueAtTime(vol,when+0.004);
  env.gain.setValueAtTime(vol*0.85,when+dur-0.015); env.gain.exponentialRampToValueAtTime(0.0001,when+dur);
  o1.connect(flt); o2.connect(flt); flt.connect(env);
  env.connect(masterGain); connectRv(env,0.22);
  o1.start(when); o1.stop(when+dur+0.02);
  o2.start(when); o2.stop(when+dur+0.02);
}

// Bass: sawtooth + resonant LP
function bassNote(when,midi,dur,vol=0.24){
  if(!audioOK)return;
  const f=mf(midi);
  const o=AC.createOscillator(); o.type='sawtooth'; o.frequency.value=f;
  const flt=AC.createBiquadFilter(); flt.type='lowpass';
  flt.frequency.setValueAtTime(f*7,when); flt.frequency.exponentialRampToValueAtTime(f*1.8,when+0.06); flt.Q.value=3.5;
  const env=AC.createGain();
  env.gain.setValueAtTime(0.0001,when); env.gain.linearRampToValueAtTime(vol,when+0.003);
  env.gain.exponentialRampToValueAtTime(vol*0.65,when+dur*0.35); env.gain.exponentialRampToValueAtTime(0.0001,when+dur);
  o.connect(flt); flt.connect(env); env.connect(masterGain);
  o.start(when); o.stop(when+dur+0.02);
}

// Pad: 3 detuned sines (ambient chord layer)
function padChord(when,midis,dur,vol=0.05){
  if(!audioOK)return;
  midis.forEach((m,i)=>{
    fmNote(when,m,dur,1.5,1.2,vol-i*0.01,i*4);
  });
}

// Kick drum
function kick(when,vol=0.75){
  if(!audioOK)return;
  const o=AC.createOscillator(); o.type='sine';
  o.frequency.setValueAtTime(240,when); o.frequency.exponentialRampToValueAtTime(28,when+0.22);
  const env=AC.createGain();
  env.gain.setValueAtTime(0.0001,when); env.gain.linearRampToValueAtTime(vol,when+0.004);
  env.gain.exponentialRampToValueAtTime(0.0001,when+0.38);
  o.connect(env); env.connect(masterGain);
  o.start(when); o.stop(when+0.42);
  // Click
  const ck=AC.createOscillator(); ck.frequency.value=1100;
  const ce=AC.createGain(); ce.gain.setValueAtTime(vol*0.28,when); ce.gain.exponentialRampToValueAtTime(0.0001,when+0.012);
  ck.connect(ce); ce.connect(masterGain); ck.start(when); ck.stop(when+0.015);
}

// Snare
function snare(when,vol=0.42){
  if(!audioOK)return;
  const dur=0.17;
  const sr=AC.sampleRate, bLen=Math.floor(sr*dur);
  const buf=AC.createBuffer(1,bLen,sr); const d=buf.getChannelData(0);
  for(let i=0;i<bLen;i++) d[i]=Math.random()*2-1;
  const ns=AC.createBufferSource(); ns.buffer=buf;
  const flt=AC.createBiquadFilter(); flt.type='bandpass'; flt.frequency.value=2800; flt.Q.value=0.8;
  const env=AC.createGain();
  env.gain.setValueAtTime(0.0001,when); env.gain.linearRampToValueAtTime(vol*0.85,when+0.002);
  env.gain.exponentialRampToValueAtTime(0.0001,when+dur);
  ns.connect(flt); flt.connect(env); env.connect(masterGain);
  ns.start(when); ns.stop(when+dur+0.01);
  // Tone body
  const tn=AC.createOscillator(); tn.type='triangle'; tn.frequency.value=190;
  const te=AC.createGain(); te.gain.setValueAtTime(0.0001,when); te.gain.linearRampToValueAtTime(vol*0.45,when+0.002);
  te.gain.exponentialRampToValueAtTime(0.0001,when+0.07);
  tn.connect(te); te.connect(masterGain); tn.start(when); tn.stop(when+0.08);
}

// Hi-hat (closed)
function hihat(when,vol=0.1){
  if(!audioOK)return;
  const sr=AC.sampleRate, bLen=Math.floor(sr*0.04);
  const buf=AC.createBuffer(1,bLen,sr); const d=buf.getChannelData(0);
  for(let i=0;i<bLen;i++) d[i]=Math.random()*2-1;
  const ns=AC.createBufferSource(); ns.buffer=buf;
  const flt=AC.createBiquadFilter(); flt.type='highpass'; flt.frequency.value=9000;
  const env=AC.createGain();
  env.gain.setValueAtTime(0.0001,when); env.gain.linearRampToValueAtTime(vol,when+0.001);
  env.gain.exponentialRampToValueAtTime(0.0001,when+0.038);
  ns.connect(flt); flt.connect(env); env.connect(masterGain);
  ns.start(when); ns.stop(when+0.05);
}

// Open hi-hat
function openHat(when,vol=0.07){
  if(!audioOK)return;
  const sr=AC.sampleRate, bLen=Math.floor(sr*0.22);
  const buf=AC.createBuffer(1,bLen,sr); const d=buf.getChannelData(0);
  for(let i=0;i<bLen;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/bLen,0.5);
  const ns=AC.createBufferSource(); ns.buffer=buf;
  const flt=AC.createBiquadFilter(); flt.type='highpass'; flt.frequency.value=7500;
  const env=AC.createGain();
  env.gain.setValueAtTime(0.0001,when); env.gain.linearRampToValueAtTime(vol,when+0.002);
  env.gain.exponentialRampToValueAtTime(0.0001,when+0.18);
  ns.connect(flt); flt.connect(env); env.connect(masterGain);
  ns.start(when); ns.stop(when+0.22);
}

// Cymbal crash
function crash(when,vol=0.12){
  if(!audioOK)return;
  const sr=AC.sampleRate, bLen=Math.floor(sr*0.6);
  const buf=AC.createBuffer(1,bLen,sr); const d=buf.getChannelData(0);
  for(let i=0;i<bLen;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/bLen,1.2);
  const ns=AC.createBufferSource(); ns.buffer=buf;
  const flt=AC.createBiquadFilter(); flt.type='highpass'; flt.frequency.value=5000;
  const env=AC.createGain();
  env.gain.setValueAtTime(0.0001,when); env.gain.linearRampToValueAtTime(vol,when+0.003);
  env.gain.exponentialRampToValueAtTime(0.0001,when+0.55);
  ns.connect(flt); flt.connect(env); env.connect(masterGain); connectRv(env,0.5);
  ns.start(when); ns.stop(when+0.65);
}

// â”€â”€ Chord Progression (Darius/RayForce dark minor feel) â”€â”€â”€
// Key: A minor   BPM: 160   Time: 4/4   Unit: 16th note
const BGM_BPM = 160;
const S16 = 60/BGM_BPM/4; // 16th note = 0.09375s

// CHORD_PROG: 8 "sections" Ã— 2 bars each = 16 bar loop
// Each: { bass: [midi offsets per 16th], arp: [midi notes], pad: [midi chord] }
const CHORD_PROG = [
  // 0-1: Am  (bars 0-1)
  { root:45, pad:[45,52,57,60], arp:[57,60,64,67, 69,67,64,60, 57,64,69,72, 67,64,60,57] },
  // 2-3: Am7 (bars 2-3)
  { root:45, pad:[45,52,55,60], arp:[55,60,64,67, 72,67,64,60, 57,55,60,64, 67,64,57,55] },
  // 4-5: F   (bars 4-5)
  { root:41, pad:[41,48,53,57], arp:[53,57,60,65, 67,65,60,57, 53,60,65,69, 67,65,57,53] },
  // 6-7: G   (bars 6-7)
  { root:43, pad:[43,50,55,59], arp:[55,59,62,67, 71,67,62,59, 55,62,67,71, 69,67,59,55] },
  // 8-9: Em  (bars 8-9)
  { root:40, pad:[40,47,52,55], arp:[52,55,59,64, 67,64,59,55, 52,59,64,67, 64,59,55,52] },
  // 10-11: Am (bars 10-11) â€“ higher octave energy
  { root:45, pad:[45,52,57,60], arp:[69,72,76,79, 81,79,76,72, 69,76,81,84, 79,76,72,69] },
  // 12-13: F â†’ Dm feel
  { root:41, pad:[38,45,50,53], arp:[50,53,57,60, 65,60,57,53, 50,57,65,69, 67,65,57,50] },
  // 14-15: G â†’ Em cadence
  { root:43, pad:[43,47,50,55], arp:[55,59,62,67, 71,74,71,67, 64,67,71,74, 76,71,67,62] },
];

// Bass pattern (per-step offset from root; -1=rest; -2=root-12)
const BASS_PAT = [
  0,-1, 0,-1,   7,-1, 5,-1,
  0,-1, 0,-1,   5, 7, 3,-1
];

// Drum patterns (16 steps)
const KICK_P  = [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,1,0];
const SNARE_P = [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,1,0];
const HIHAT_P = [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1];
const OHAT_P  = [0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,1];
// Accent: snare roll on bar 7, 15 (energy builds)
const ROLL_P  = [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,1];

// â”€â”€ Sequencer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LOOKAHEAD=0.13, SCHED_MS=75;

function scheduleBGMStep(step, bar, when){
  const chord = CHORD_PROG[Math.floor(bar/2) % CHORD_PROG.length];
  const isRollBar = (bar % 16 === 7 || bar % 16 === 15);

  // Drums
  if(KICK_P[step])  kick(when, 0.78);
  if(isRollBar && ROLL_P[step]) snare(when, 0.25);
  else if(SNARE_P[step]) snare(when, 0.44);
  if(HIHAT_P[step]) hihat(when, step%2===0 ? 0.11 : 0.07);
  if(OHAT_P[step])  openHat(when, 0.08);
  if(step===0 && bar%8===0) crash(when, 0.14);

  // Bass
  const bOff=BASS_PAT[step];
  if(bOff>=0) bassNote(when, chord.root+bOff, S16*1.25, 0.26);
  else if(bOff===-2) bassNote(when, chord.root-12, S16*1.8, 0.2);

  // Lead arpeggio
  const arpMidi = chord.arp[step % chord.arp.length];
  const arpDur = step%4===3 ? S16*0.5 : S16*0.88;
  leadNote(when, arpMidi, arpDur, 0.11);

  // FM bell accent on off-beats (ZUNTATA signature texture)
  if(step===2||step===6||step===10||step===14){
    const bellMidi = chord.arp[(step+4)%chord.arp.length]+12;
    fmNote(when, bellMidi, S16*2, 3, 5, 0.06, 0);
  }

  // Pad chord every half-bar (every 8 steps)
  if(step===0 || step===8){
    padChord(when, chord.pad.slice(0,3), S16*8*0.9, 0.05);
  }
}

function bgmTick(){
  if(!audioOK||!bgmRunning) return;
  const now=AC.currentTime;
  while(bgmNextNote < now+LOOKAHEAD){
    scheduleBGMStep(bgmStep, bgmBar, bgmNextNote);
    bgmNextNote+=S16;
    bgmStep++;
    if(bgmStep>=16){ bgmStep=0; bgmBar++; }
  }
}

function startBGM(){
  if(!audioOK) return;
  stopBGM();
  bgmRunning=true; bgmStep=0; bgmBar=0;
  bgmNextNote=AC.currentTime+0.06;
  bgmInterval=setInterval(bgmTick, SCHED_MS);
}
function stopBGM(){
  bgmRunning=false;
  if(bgmInterval){ clearInterval(bgmInterval); bgmInterval=null; }
}

// â”€â”€ Bonus loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startBonus(){
  if(!audioOK||bonusT) return;
  // Fast pentatonic arpeggio in high register
  const seq=[81,84,88,91,93,91,88,84]; let ph=0;
  const tick=()=>{
    if(!bonusT) return;
    const t=AC.currentTime;
    leadNote(t, seq[ph%seq.length], 0.075, 0.13);
    fmNote(t, seq[ph%seq.length]+12, 0.05, 2, 3, 0.05);
    ph++;
    bonusT=setTimeout(tick, 94);
  };
  bonusT=setTimeout(tick,0);
}
function stopBonus(){ if(bonusT){clearTimeout(bonusT);bonusT=null;} }

// â”€â”€ SFX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sfx(type){
  if(!audioOK) return;
  const t=AC.currentTime;
  if(type==='milestone'){
    // Ascending FM fanfare
    [60,64,67,72,76].forEach((n,i)=>{
      leadNote(t+i*0.055, n, 0.2, 0.18);
      fmNote(t+i*0.055, n+12, 0.18, 2.5, 4, 0.09);
    });
    crash(t+0.22, 0.14);
  } else if(type==='zone_safe'){
    fmNote(t, 52, 0.12, 1, 2, 0.12); fmNote(t+0.09, 48, 0.18, 1, 1.5, 0.1);
    stopBonus();
  } else if(type==='zone_bonus'){
    [60,64,67,72].forEach((n,i)=>{ leadNote(t+i*0.04, n, 0.12, 0.15); fmNote(t+i*0.04, n+12, 0.1, 2, 4, 0.08); });
    startBonus();
  } else if(type==='zone_normal'){
    fmNote(t, 60, 0.07, 1, 1, 0.1); stopBonus();
  } else if(type==='explode'){
    stopBonus();
    // Layered explosion
    const dur=0.55, sr=AC.sampleRate;
    const buf=AC.createBuffer(2,Math.floor(sr*dur),sr);
    for(let ch=0;ch<2;ch++){
      const d=buf.getChannelData(ch);
      for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,1.4);
    }
    const ns=AC.createBufferSource(); ns.buffer=buf;
    const flt=AC.createBiquadFilter(); flt.type='lowpass'; flt.frequency.value=700;
    const g=AC.createGain(); g.gain.setValueAtTime(0.001,t); g.gain.exponentialRampToValueAtTime(0.95,t+0.012);
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    ns.connect(flt); flt.connect(g); g.connect(masterGain); connectRv(g,0.6);
    ns.start(t); ns.stop(t+dur+0.01);
    // Sub boom
    const bm=AC.createOscillator(); bm.type='sine';
    bm.frequency.setValueAtTime(90,t); bm.frequency.exponentialRampToValueAtTime(22,t+0.42);
    const be=AC.createGain(); be.gain.setValueAtTime(0.001,t); be.gain.exponentialRampToValueAtTime(0.9,t+0.01);
    be.gain.exponentialRampToValueAtTime(0.0001,t+0.46);
    bm.connect(be); be.connect(masterGain); bm.start(t); bm.stop(t+0.5);
  } else if(type==='start'){
    // Power-up sweep
    [48,52,55,60,64,67,72].forEach((n,i)=>{
      fmNote(t+i*0.038, n, 0.18, 2, 4, 0.1);
      if(i%2===0) leadNote(t+i*0.038, n+12, 0.15, 0.09);
    });
    crash(t+0.25, 0.15);
  }
}

// â”€â”€â”€ Game Flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameOver() {
  if (dead) return;
  dead=true; paused=true; running=false;
  explode(player.x, player.y); screenShake=28;
  stopBGM(); sfx('explode');
  const fs=Math.floor(score);
  try { hiscore=Math.max(hiscore,fs); localStorage.setItem('tamayoke_reborn_hi',hiscore); } catch(e){}
  setTimeout(()=>{
    showOverlay(`
      <div class="ov-logo" style="color:#ff3333;text-shadow:0 0 18px #ff3333,0 0 60px #ff333388">GAME OVER</div>
      <div class="ov-sub" style="color:#ff6666">SCORE: <span style="color:#ffe066;font-size:1.4em">${fs}</span></div>
      <div class="ov-sub">BEST: <span style="color:#fff">${hiscore}</span></div>
      <button class="start-btn" id="startBtn" style="margin-top:1.6em;border-color:#ff3333;color:#ff3333;box-shadow:0 0 18px #ff333355,inset 0 0 18px #ff333322">â†º RETRY</button>
    `);
    document.getElementById('startBtn').addEventListener('click', startGame);
  }, 400);
}

function startGame() {
  initAudio();
  if (AC?.state==='suspended') AC.resume();
  running=true; paused=false; dead=false;
  time=0; score=0; difficulty=1; zone='normal'; screenShake=0;
  bullets.length=0; particles.length=0; shockwaves.length=0; banners.length=0;
  player.x=W/2; player.y=H*0.82; player.trail.length=0;
  nextMile=2000; mileCount=0; spiralA=0;
  Object.keys(timers).forEach(k=>delete timers[k]);
  hideOverlay();
  startBGM(); sfx('start');
}

function togglePause() {
  if (!running) return;
  paused=!paused;
  if (paused) {
    stopBGM();
    showOverlay(`
      <div class="ov-logo" style="color:#ffe066;text-shadow:0 0 18px #ffe066">PAUSED</div>
      <div class="ov-sub">ã‚¿ãƒƒãƒ— / SPACE ã§å†é–‹</div>
      <button class="start-btn" id="startBtn" style="border-color:#ffe066;color:#ffe066">â–¶ RESUME</button>
    `);
    document.getElementById('startBtn').addEventListener('click',()=>{paused=false;hideOverlay();startBGM();});
  } else {
    hideOverlay(); startBGM();
  }
}

// â”€â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.addEventListener('keydown', e=>{
  ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].forEach(k=>{ if(e.key===k) e.preventDefault(); });
  keys.add(e.code);
  if (e.code==='Space') { if(dead||!running) startGame(); else togglePause(); }
  if (e.code==='KeyR') startGame();
  if (e.code==='Enter' && !running) startGame();
});
window.addEventListener('keyup', e=>keys.delete(e.code));
window.addEventListener('blur', ()=>keys.clear());

const wrap = document.getElementById('wrap');
wrap.addEventListener('pointerdown', e=>{
  if (overlay.style.display!=='none') return;
  initAudio(); if(AC?.state==='suspended') AC.resume();
  ptr.active=true;
  const rc=cv.getBoundingClientRect();
  ptr.x=(e.clientX-rc.left)*(W/rc.width);
  ptr.y=(e.clientY-rc.top)*(H/rc.height);
});
wrap.addEventListener('pointermove', e=>{
  if (!ptr.active) return;
  const rc=cv.getBoundingClientRect();
  ptr.x=(e.clientX-rc.left)*(W/rc.width);
  ptr.y=(e.clientY-rc.top)*(H/rc.height);
});
window.addEventListener('pointerup', ()=>ptr.active=false);

document.getElementById('pauseBtn').addEventListener('click', ()=>{ if(!running) startGame(); else togglePause(); });
document.getElementById('retryBtn').addEventListener('click', startGame);
document.getElementById('startBtn').addEventListener('click', startGame);

['touchstart','mousedown','pointerdown'].forEach(ev=>{
  document.body.addEventListener(ev,()=>{ initAudio(); if(AC?.state==='suspended') AC.resume(); },{passive:true,once:true});
});

// â”€â”€â”€ Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastT=performance.now();
(function loop(now) {
  const dt=Math.min(0.05,(now-lastT)/1000); lastT=now;
  if (running&&!paused&&!dead) update(dt);
  draw();
  requestAnimationFrame(loop);
})(lastT);
</script>
</body>
</html>
